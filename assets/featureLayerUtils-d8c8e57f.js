import{ap as A,aq as Y,ar as m,as as _,at as P,au as I,av as c,aw as $,ax as z,ay as y,az as T}from"./index-3572d442.js";import{I as G,y as E,w as N,b as k,u as B,v as j,l as x,d as q,m as b}from"./utils-a5772e52.js";import{t as V}from"./fetchService-8a20b478.js";import{a as C}from"./lazyLayerLoader-5d9fbd85.js";import{o as g}from"./jsonContext-bb78002a.js";const h="Feature Service",w="feature-layer-utils",H=`${w}-save`,Q=`${w}-save-as`,p=`${w}-saveall`,f=`${w}-saveall-as`;function v(a){return{isValid:z(a)&&(a.type!=="feature"||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function O(a){const e=[],t=[];for(const{layer:n,layerJSON:o}of a)n.isTable?t.push(o):e.push(o);return{layers:e,tables:t}}function F(a){return O([a])}async function J(a,e){return/\/\d+\/?$/.test(a.url)?F(e[0]):M(e,a)}async function M(a,e){if(!e)return a.reverse(),O(a);const{layer:{url:t,customParameters:n,apiKey:o}}=a[0];let r=await e.fetchData("json");(r==null?void 0:r.layers)!=null&&(r==null?void 0:r.tables)!=null||(r=await W(r,{url:t??"",customParameters:n,apiKey:o},a.map(s=>s.layer.layerId)));for(const s of a)R(s.layer,s.layerJSON,r);return r}async function W(a,e,t){a||(a={}),a.layers||(a.layers=[]),a.tables||(a.tables=[]);const{url:n,customParameters:o,apiKey:r}=e,{serviceJSON:s,layersJSON:l}=await V(n,{customParameters:o,apiKey:r}),i=S(a.layers,s.layers,t),u=S(a.tables,s.tables,t);a.layers=i.itemResources,a.tables=u.itemResources;const d=[...i.added,...u.added],K=l?[...l.layers,...l.tables]:[];return await X(a,d,n,K),a}function S(a,e,t){const n=Y(a,e,(r,s)=>r.id===s.id);a=a.filter(r=>!n.removed.some(s=>s.id===r.id));const o=n.added;return o.forEach(({id:r})=>{a.push({id:r})}),{itemResources:a,added:o.filter(({id:r})=>!t.includes(r))}}async function X(a,e,t,n){const o=await Z(e),r=e.map(({id:s,type:l})=>new(o.get(l))({url:t,layerId:s,sourceJSON:n.find(({id:i})=>i===s)}));await Promise.allSettled(r.map(s=>s.load())),r.forEach(s=>{const{layerId:l,loaded:i,defaultPopupTemplate:u}=s;if(!i||u==null)return;const d={id:l,popupInfo:u.toJSON()};s.operationalLayerType!=="ArcGISFeatureLayer"&&(d.layerType=s.operationalLayerType),R(s,d,a)})}async function Z(a){const e=[];a.forEach(({type:o})=>{const r=aa(o),s=C[r];e.push(s())});const t=await Promise.all(e),n=new Map;return a.forEach(({type:o},r)=>{n.set(o,t[r])}),n}function aa(a){let e;switch(a){case"Feature Layer":case"Table":e="FeatureLayer";break;case"Oriented Imagery Layer":e="OrientedImageryLayer"}return e}function R(a,e,t){a.isTable?L(t.tables,e):L(t.layers,e)}function L(a,e){const t=a.findIndex(({id:n})=>n===e.id);t===-1?a.push(e):a[t]=e}function D(a,e){if(!a.length)throw new y(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ea(a,e){const t=a.map(n=>n.portalItem.id);if(new Set(t).size>1)throw new y(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(a,e){const t=a.map(n=>n.layerId);if(new Set(t).size!==t.length)throw new y(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function ta(a){D(a,p),await Promise.all(a.map(e=>e.load()));for(const e of a)x(e,p,v),q({layer:e,itemType:h,errorNamePrefix:p});ea(a,p),U(a,p)}async function ra(a,e){const{url:t,layerId:n,title:o,fullExtent:r,isTable:s}=a,l=m(t);e.url=(l==null?void 0:l.serverType)==="FeatureServer"?t:`${t}/${n}`,e.title||(e.title=o),e.extent=null,s||r==null||(e.extent=await P(r)),I(e,c.METADATA),I(e,c.MULTI_LAYER),T(e,c.SINGLE_LAYER),s&&T(e,c.TABLE)}function sa(a,e){for(const r of a){const s=r.parsedUrl.path,l=m(s);if(!(l==null?void 0:l.url.path))throw new y(`${e}:invalid-parameters`,b(r,`has unsupported url pattern: ${s}`),{layer:r});const u=l==null?void 0:l.serverType;if(u!=="FeatureServer"&&u!=="MapServer")throw new y(`${e}:invalid-parameters`,b(r,`has unsupported server type: ${u}`),{layer:r});if(u==="MapServer"&&a.length>1)throw new y(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=m(a[0].parsedUrl.path),n=t==null?void 0:t.url.path;if(!a.every(r=>{const s=m(r.parsedUrl.path);return(s==null?void 0:s.url.path)===n}))throw new y(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function na(a){D(a,f),await Promise.all(a.map(e=>e.load()));for(const e of a)x(e,f,v);sa(a,f),U(a,f)}async function la(a,e){let t=0,n=0;for(const{isTable:s}of e)s?n++:t++;const o=e[0].parsedUrl.path,r=m(o);if(a.url=(r==null?void 0:r.serverType)==="FeatureServer"?r.url.path:o,a.title||(a.title=r.title),a.extent=null,t>0){const s=e.map(l=>l.fullExtent).filter(_).reduce((l,i)=>l.clone().union(i));s&&(a.extent=await P(s))}I(a,c.METADATA),$(a,c.MULTI_LAYER,e.length>1),$(a,c.SINGLE_LAYER,e.length===1),$(a,c.TABLE,n>0&&t===0),N(a)}async function pa(a,e){return G({layer:a,itemType:h,validateLayer:v,createItemData:(t,n)=>J(n,[t]),errorNamePrefix:H},e)}async function fa(a,e){await ta(a);const t=a[0].portalItem,n=g(t),o=await Promise.all(a.map(s=>E(s,n,e))),r=await J(t,a.map((s,l)=>({layer:s,layerJSON:o[l]})));return N(t),await t.update({data:r}),await Promise.all(a.slice(1).map(s=>s.portalItem.reload())),A(n),t.clone()}async function ma(a,e,t){return k({layer:a,itemType:h,validateLayer:v,createItemData:(n,o)=>Promise.resolve(F(n)),errorNamePrefix:Q,newItem:e,setItemProperties:ra},t)}async function da(a,e,t){await na(a);const n=B({itemType:h,errorNamePrefix:f,newItem:e}),o=g(n),r=await Promise.all(a.map(l=>E(l,o,t))),s=await M(a.map((l,i)=>({layer:l,layerJSON:r[i]})));await la(n,a),await j(n,s,t);for(const l of a)l.portalItem=n.clone();return A(o),n}export{pa as save,fa as saveAll,da as saveAllAs,ma as saveAs};
