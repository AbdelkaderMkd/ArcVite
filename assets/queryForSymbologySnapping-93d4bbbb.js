import{jX as D,dq as $,jY as q,jZ as z,bY as S,j_ as C,j$ as F,k0 as G,k1 as O,d4 as k}from"./index-383689b1.js";async function P(s,d,l,p,r){const{elevationProvider:h,renderCoordsHelper:c,spatialReference:j}=s,{elevationInfo:y}=d,I=q(y,!0),m=await z(I,j,r);S(r);const i=[],u=new Set,f=new Set;for(const{objectId:e,points:t}of p){const n=l(e);if(n==null){for(const o of t)i.push(o.z??0);u.add(e);continue}n.isDraped&&f.add(e);const a=n.graphic.geometry;b.setFromElevationInfo(C(a,y)),b.updateFeatureExpressionInfoContext(m,n.graphic,d),g.spatialReference=s.spatialReference;for(const{x:o,y:v,z:x}of t)g.x=o,g.y=v,g.z=x??0,F(g,h,b,c,w),i.push(w.z)}return{elevations:i,drapedObjectIds:f,failedObjectIds:u}}const b=new G,g=D(0,0,0,$.WGS84),w=new O;async function Y(s,d,l){if(s==null||d.candidates.length===0)return R;const p=s.graphics3DGraphicsByObjectID??s.graphics3DGraphics,r=[],h=[],{renderer:c}=s,j=c!=null&&"arcadeRequired"in c&&c.arcadeRequired?k():null,y=async(e,{graphic:t,graphics3DSymbol:n})=>{const a=await j,o=await s.getRenderingInfoAsync(t,c,a,{signal:l});return o==null?[]:n.queryForSnapping(e,m,o,l)},{candidates:I,spatialReference:m}=d;for(let e=0;e<I.length;++e){const t=I[e],{objectId:n}=t,a=typeof n=="number"?p==null?void 0:p.get(n):void 0;if(a==null)continue;const{graphics3DSymbol:o}=a;o.symbologySnappingSupported&&(r.push(y(t,a)),h.push(e))}if(r.length===0)return R;const i=await Promise.all(r);S(l);const u=[],f=[];for(let e=0;e<i.length;++e){const t=i[e],n=h[e];for(const a of t)u.push(a),f.push(n)}return{candidates:u,sourceCandidateIndices:f}}const R={candidates:[],sourceCandidateIndices:[]};export{P as f,Y as r};
