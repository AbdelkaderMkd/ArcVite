import{pX as N,pY as D,pW as A,b3 as z,bY as F,bd as U,q0 as G,q2 as W,q3 as j,iu as O,iF as Q,iv as R,p_ as _,bb as $,aA as Y,q4 as Z,q5 as K,ea as X,b0 as J,cD as ee,eZ as te,dQ as ie,aP as H,aQ as u,aR as g,aT as se}from"./index-383689b1.js";import{i as le,e as ae,l as re,h as ne,t as oe}from"./TileInfoViewPOT-dd6daa2b.js";import{_ as he,d as ce,f as de,o as ue,a as ge}from"./WGLBrushVTLSymbol-7648093c.js";import{o as pe}from"./VTLMaterialManager-330b0a63.js";import{l as x}from"./StyleRepository-72a54356.js";import{n as me}from"./LayerView3D-80043e5c.js";import{o as ye}from"./TiledLayerView3D-e6590a07.js";import{d as _e}from"./LayerView-fd5dbfea.js";import"./Rect-ea14f53a.js";import"./pbf-1f7c5ba7.js";import"./rasterizingUtils-465ce7c6.js";import"./definitions-24f6db57.js";import"./enums-b1d611e3.js";import"./number-e491b09e.js";import"./GeometryUtils-dd03fc25.js";import"./ShaderCompiler-77d0dcb6.js";import"./programUtils-f035fe8a.js";import"./GeometryUtils-984e8446.js";class fe{constructor(e,t,i){this._scale=e,this._shift=t,this._levelShift=i}getLevelRowColumn(e){const t=this.getLevelShift(e[0]),i=this._shift+t;return i?[e[0]-t,e[1]>>i,e[2]>>i]:e}getLevelShift(e){return Math.min(e,this._levelShift)}getOffset(e,t){let i=0,a=0;const l=this._shift+this.getLevelShift(e[0]);if(l){const s=(1<<l)-1,n=t/(this._scale*(1<<l-1));i=(e[2]&s)*n,a=(e[1]&s)*n}return[i,a]}getScale(e){return this._scale*(1<<this._shift+this.getLevelShift(e))}}function ve(r){const e=[],t=new le(4096,e,()=>{const a=new A;return a.show=!1,a.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),a.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),a}),i=new ae(e,t,(a,l,s)=>new re(a,l,s,r.styleRepository,r.key.level,0),(a,l)=>{N(a,l,!1)},()=>0,a=>{const l=r.styleRepository.getStyleLayerByUID(a).getLayoutProperty("visibility");return!l||l.getValue()!==D.NONE});e.push(r),t.add(r),i.setScreenSize(512,512),i.continue(1/0)}class E extends ne{constructor(e,t,i,a){super(e,t,i),this._memCache=a,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new oe(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t,i,a){const l=new z(e,t,i,0);let s=this._memCache.get(l.id);if(s!=null)return s.retain(),s;const n=await this._getVectorTileData(l);if(F(a),!this._layer)return null;if(s=this._memCache.get(l.id),s!=null)return s.retain(),s;const o=this._layer.tileInfo.getTileBounds(U(),l),f=this._tileInfoView.getTileResolution(e);return s=new G(l,f,o[0],o[3],512,512,this._styleRepository,this._memCache),n?(s.setData(n),s.retain(),this._memCache.put(l.id,s,s.memoryUsed,W)):s.setData(null),s.neededForCoverage=!0,s.transforms.tileUnitsToPixels=j(1/8,0,0,0,1/8,0,0,0,1),ve(s),s}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,a={signal:i.signal},l=this._getParsedVectorTileData(e,a).then(s=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),s)).catch(()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null));return this._ongoingTileRequests.set(t,l),this._ongoingRequestToController.set(t,i),l}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then(i=>this.parseTileData({key:e,data:i},t))}}const Ce={vtlBackground:he,vtlFill:ce,vtlLine:de,vtlCircle:ue,vtlSymbol:ge},P=1e-6;class q{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache=new Map,this._vtlMaterialManager=new pe}dispose(){this._brushCache&&(this._brushCache.forEach(e=>e.dispose()),this._brushCache=null),this._vtlMaterialManager=O(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,t,i,a){const{context:l}=e,s=i.layers;i.backgroundBucketIds.length>0&&(e.renderPass="background",i.backgroundBucketIds.forEach(n=>{const o=i.getLayerById(n);a!=null&&a!==o.type||this._renderStyleLayer(o,e,t,!0)})),l.setBlendingEnabled(!1),l.setDepthTestEnabled(!0),l.setDepthWriteEnabled(!0),l.setDepthFunction(Q.LEQUAL),e.renderPass="opaque";for(let n=s.length-1;n>=0;n--){const o=s[n];a!=null&&a!==o.type||this._renderStyleLayer(o,e,t,!1)}l.setDepthWriteEnabled(!1),l.setBlendingEnabled(!0),l.setBlendFunctionSeparate(R.ONE,R.ONE_MINUS_SRC_ALPHA,R.ONE,R.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent";for(let n=0;n<s.length;n++){const o=s[n];a!=null&&a!==o.type||this._renderStyleLayer(o,e,t,!1)}l.setDepthTestEnabled(!1),l.bindVAO()}_renderStyleLayer(e,t,i,a){if(!(a||e&&i.layerData.has(e.uid)))return;const l=e.getLayoutProperty("visibility");if(l&&l.getValue()===D.NONE)return;const{renderPass:s}=t;let n;switch(e.type){case _.BACKGROUND:if(s!=="background")return;n="vtlBackground";break;case _.FILL:if(s!=="opaque"&&t.renderPass!=="translucent")return;n="vtlFill";break;case _.LINE:if(s!=="translucent")return;n="vtlLine";break;case _.CIRCLE:if(s!=="translucent")return;n="vtlCircle";break;case _.SYMBOL:if(s!=="translucent")return;n="vtlSymbol"}const o=t.displayLevel;e.minzoom!==void 0&&e.minzoom>o+P||e.maxzoom!==void 0&&e.maxzoom<=o-P||(t.styleLayerUID=e.uid,t.styleLayer=e,this._drawWithBrush(t,i,n))}_drawWithBrush(e,t,i){if(!this._brushCache.has(i)){const a=Ce[i];this._brushCache.set(i,new a)}this._brushCache.get(i).drawMany(e,[t])}}let c=class extends ye(me(_e)){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=$("disable-feature:vtl-level-shift")?0:1,this.contentZoom=$("disable-feature:vtl-level-shift")?1:1.5}initialize(){if(this.layer.fullExtent==null)return void this.addResolvingPromise(Promise.reject(new Y("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:r,spatialReference:e,state:t,viewingMode:i}=this.view,a=i==="local"&&!Z(e)||K.force512VTL,l=this.layer.tileInfo.spatialReference.isGeographic,s=a?this.layer.tileInfo:this.layer.tileInfo.getOrCreateCompatible(256,l?1:2),n=this._getTileInfoSupportError(s,this.layer.fullExtent);if(n!=null)return this.addResolvingPromise(Promise.reject(n));const o=X(()=>{var h,d;return(d=(h=this.view)==null?void 0:h.basemapTerrain)==null?void 0:d.tilingSchemeLocked}).then(()=>{var w,y,M;const h=r.tilingScheme,d=h.pixelSize,S=d===256?1:2,p=(w=r.spatialReference)!=null&&w.isGeographic&&d===256?1:0,v=(y=r.spatialReference)!=null&&y.isGeographic||d!==256?0:1;let m;if(this.schemaHelper=new fe(S,p,this.levelShift+v),d===256){const B=this.layer.tileInfo.spatialReference.isGeographic;m=this.layer.tileInfo.getOrCreateCompatible(256,B?1:2)}else m=(M=this.view.spatialReference)!=null&&M.isGeographic?this.layer.tileInfo.getOrCreateCompatible(512,.5):this.layer.tileInfo;const C=this._getTileInfoCompatibilityError(m,h);if(C)throw C;this.tileInfo=m});this._tileHandlerController=new AbortController;const f=this.view.resourceController;this._memCache=f.memoryController.newCache(`vtl-${this.layer.uid}`,h=>{h.release()}),this.handles.add(J(()=>this.view.qualitySettings.memoryLimit,h=>this._memCache.maxSize=Math.ceil(h/10*1048576),ee));const k=new x(this.layer.currentStyleInfo.style);this._tileHandler=new E(this.layer,k,t.contentPixelRatio,this._memCache);const b=this._tileHandlerController.signal,L=we(f),T=this._tileHandler.start({signal:b,schedule:L}),I=this._tileHandler.spriteMosaic;I.then(h=>{!te(b)&&this._tileHandler&&(this.painter=new q(h,this._tileHandler.glyphMosaic))}),T.then(()=>this._tileHandlerController=null),this.updatingHandles.add(()=>{var h;return{style:this.layer.currentStyleInfo.style,pixelRatio:(h=this.view.state)==null?void 0:h.contentPixelRatio}},({style:h,pixelRatio:d})=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const S=new x(h),p=new E(this.layer,S,d,this._memCache),v=p.start({signal:this._tileHandlerController.signal,schedule:L}),m=p.spriteMosaic;v.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([v,m]).then(([,C])=>{const w=this._tileHandler,y=this.painter;this.painter=new q(C,p.glyphMosaic),this._tileHandler=p,this.emit("data-changed"),w.destroy(),y&&y.dispose()}))});const V=Promise.all([o,T,I]);this.addResolvingPromise(V)}destroy(){this.painter=O(this.painter),this._tileHandlerController=ie(this._tileHandlerController),this._tileHandler=H(this._tileHandler),this._memCache=H(this._memCache)}get displayLevelRange(){const r=this.tileInfo.lods,e=this.layer.minScale||r[0].scale,t=this.layer.maxScale||r[r.length-1].scale,i=this.levelRangeFromScaleRange(e,t);return this.layer.maxScale?i.maxLevel++:i.maxLevel+=this.levelShift,i}get dataScaleRange(){const r=this.tileInfo.lods;return{minScale:r[0].scale,maxScale:r[r.length-1].scale}}get dataLevelRange(){const{minScale:r,maxScale:e}=this.dataScaleRange,t=this.levelRangeFromScaleRange(r,e);return t.minLevel===1&&this.tileInfo.size[0]===256&&(t.minLevel=0),t.maxLevel+=this.levelShift,t}async fetchTile(r,e,t,i){return this._tileHandler.getVectorTile(r,e,t,i)}};u([g()],c.prototype,"layer",void 0),u([g()],c.prototype,"levelShift",void 0),u([g()],c.prototype,"contentZoom",void 0),u([g()],c.prototype,"displayLevelRange",null),u([g()],c.prototype,"tileInfo",void 0),u([g()],c.prototype,"dataScaleRange",null),u([g()],c.prototype,"dataLevelRange",null),u([g()],c.prototype,"updatingProgressValue",void 0),c=u([se("esri.views.3d.layers.VectorTileLayerView3D")],c);const Ne=c;function we(r){return e=>r.immediate.schedule(e)}export{Ne as default};
