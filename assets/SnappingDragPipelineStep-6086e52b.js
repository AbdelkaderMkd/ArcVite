import{df as G,aR as A,dg as L,dh as M,di as N,aW as D,dj as R,dk as W,dl as j}from"./index-3572d442.js";import{r as q}from"./dehydratedFeatureComparison-931d5da5.js";import{U as B}from"./dragEventPipeline-97b76120.js";import{e as J}from"./SnappingContext-1f46e914.js";function tn({predicate:n=()=>!0,snappingManager:e,snappingContext:o,updatingHandles:a,useZ:t=!0}){const i=new B;if(e==null)return{snappingStep:[z,i],cancelSnapping:z};let p,u=null,l=null,c=null;const d=()=>{u=D(u),e.doneSnapping(),l==null||l.frameTask.remove(),l=null,p=R(p),c=null},m=K(e,t,i);let f=null,s=null,Z=null;return{snappingStep:[r=>{if(!n(r))return r;const{action:P}=r;if(P==="start"){const{info:x}=r,S=Q(e.view);if(l=V(o,r,S),l.context.selfSnappingZ=null,!t&&x!=null){const g=Y(o.coordinateHelper,x.handle.component);g!=null&&(l.context.selfSnappingZ={value:g,elevationInfo:o.elevationInfo??G})}}if(l!=null){const{context:x,originalScenePos:S,originalPos:g}=l,{mapEnd:k,mapStart:T,scenePoints:E}=r,v=U(g,y(k,T)),w=y(T,g),H={...r,action:"update"},O=l.context,h=X(S,E),I=e.update({point:v,scenePoint:h,context:x});if(Z=I,C(k,I,w,t),f=v,s=h,P!=="end"){const{frameTask:b}=l;u==null&&(u=new AbortController),c=F=>{a.addPromise(W(m({frameTask:b,event:H,context:O,point:v,scenePoint:h,delta:w,getLastState:()=>({point:f,scenePoint:s,updatePoint:F.forceUpdate?null:Z})},u.signal)))},c({forceUpdate:!1}),p==null&&(p=A(()=>e.options.effectiveEnabled,()=>c==null?void 0:c({forceUpdate:!0})))}}return P==="end"&&d(),r},i],cancelSnapping:r=>(d(),r)}}function K(n,e,o){return j(async({frameTask:a,point:t,scenePoint:i,context:p,event:u,delta:l,getLastState:c},d)=>{const m=await a.schedule(()=>n.snap({point:t,scenePoint:i,context:p,signal:d}),d);if(m.valid){let f=await a.schedule(()=>m.apply(),d);const s=c();s.point!=null&&t!==s.point&&(f=n.update({point:s.point,scenePoint:s.scenePoint,context:p})),s.updatePoint!=null&&q(f,s.updatePoint)||(C(u.mapEnd,f,l,e),o.execute(u))}})}function Q(n){return n.type==="3d"?n.resourceController.scheduler.registerTask(L.SNAPPING):M}function V(n,e,o){return{context:new J({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:e.info!=null?e.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:e.snapOrigin!=null?n.coordinateHelper.vectorToDehydratedPoint(e.snapOrigin):e.mapStart,originalScenePos:e.scenePoints!=null?e.scenePoints.sceneStart:null,frameTask:o}}function U(n,[e,o,a]){const t=N(n);return t.x+=e,t.y+=o,t.hasZ&&(t.z+=a),t}function X(n,e){return n==null||e==null?null:U(n,y(e.sceneEnd,e.sceneStart))}function y(n,e){const o=n.hasZ&&e.hasZ?n.z-e.z:0;return[n.x-e.x,n.y-e.y,o]}function C(n,e,[o,a,t],i){n.x=e.x+o,n.y=e.y+a,i&&n.hasZ&&e.hasZ&&(n.z=e.z+t)}function Y(n,e){if(!n.hasZ())return null;const o=e.vertices;let a=null;for(const t of o){const i=n.getZ(t.pos);if(a!=null&&i!=null&&Math.abs(i-a)>1e-6)return null;a==null&&(a=i)}return a}function z(n){return n}export{tn as f};
